:lab: 1
:imagesdir: ../images
:sectnums:
:source-language: c
:listing-caption: Program
:example-caption: Exercise
:xrefstyle: short
:experimental:
:nrf-toolchain: v2.6.1
:nrf-sdk: 2.6.1
= Lab 1

== Installing the tools

=== nRF Command Line Tools

Nordic Semiconductor provides a collection of tools in a package called **nRF Command Line Tools** that perform important tasks including the transfer of a program from your development computer to the microcontroller. We will not use them directly, but they are required for the other tools that we will use.

. Download the https://www.nordicsemi.com/Products/Development-tools/nRF-Command-Line-Tools/Download[nRF Command Line Tools] from Nordic Semiconductor.
. Install the tools. This also includes a separate installer for the required SEGGER J-Link software.

=== Visual Studio Code

We will be using Visual Studio Code throughout these activities. If you do not already have it installed, download it from https://code.visualstudio.com/.

Once you have VS Code running, you need to install several extensions:

* https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools[C/C++]
* https://marketplace.visualstudio.com/items?itemName=bierner.markdown-mermaid[Markdown Preview Mermaid Support]
* https://marketplace.visualstudio.com/items?itemName=nordic-semiconductor.nrf-connect-extension-pack[nRF Connect for VS Code Extension Pack]
* https://marketplace.visualstudio.com/items?itemName=MS-vsliveshare.vsliveshare[Live Share] (only required for pair programming activities)

You can install by following the links above or from within VS Code using the Extensions side bar. You open this by clicking on the Extensions icon in the Activity bar.

[#img-vscode-activitybar-extensions]
.Activity bar in Visual Studio Code with Extensions icon highlighted.
image::vs-code-extension-panel-icon.png[Activity Bar, 47, 285]

From the Extensions side bar you can search for the extensions listed above and then install from their page within VS Code.

=== Select an nRF Connect toolchain and SDK 

. Open the nRF Connect side bar by clicking on its icon in the Activity bar.
+
[#img-manage-toolchain-sdk]
.Manage the nRF Connect toolchain and SDK from the nRF Connect side bar.
image::nrf-connect-manage-toolchain-sdk.png[Activity Bar, 284, 465]
+
. Click on **Manage Toolchains** and then select the **Install Toolchain** action.
.. These guides were tested using {nrf-toolchain}. Avoid using a more recent major version (a different leading number) even if one is available but it should be safe to use a more recent minor version (a greater number after the first `.`) if you prefer.  
.. Once all selections have been made, it triggers a substantial download and install process so be prepared to wait for several minutes.
. Click on **Manage SDKs** and then select the **Install SDK** action.
.. These guides were tested using SDK {nrf-sdk}. You want a version that matches that of the toolchain you just installed. Avoid `main` or numbered versions ending in `-dev` or `-cs` as these are not intended for widespread use.
.. You will be asked to select a location for the SDK. The goal is to have a short path name and avoid folder names that have spaces.



=== Git and GitHub

We will be using Git throughout these activities. If you do not already have it installed, download it from https://git-scm.com/downloads/.

You also need a https://github.com/[GitHub] account.

After you have installed Git and created a GitHub account, open a terminal in VS Code by typing kbd:[Ctrl+`]. Note that this is the **left** single quote, typically located on the same key as kbd:[~]. It is not the right single quote/apostrophe (located on the same key as kbd:["]). You are now ready to tell the computer about the GitHub username that you are using and your email address.
[source,shell]
----
git config --global user.name "yourusername" <1>
git config --global user.email "email@youremail.com" <2>
----
<1> `yourusername` should replaced with your GitHub username.
<2> `email@youremail.com` should be replaced with the email address associated with your GitHub account.

== An embedded "`Hello, world`"

On a general purpose computer the stereotypical first program in a language displays `Hello, world!` on the screen. In the world of microcontrollers the equivalent is to flash an LED. This is also called a heartbeat program. It is a simple way to indicate that your microcontroller is alive and you are able to transfer a simple program to it. Most development boards will have one or more integrated LEDs, so no external connections are necessary. The https://www.nordicsemi.com/Products/Development-hardware/nRF52840-DK[Nordic Semiconductor nRF52840 DK] that will be our example development board has four integrated LEDs. The first program will flash one of these, labeled LED1, off and on forever (or as long as the microcontroller is powered). Flow charts are a useful tool for planning and documenting code, so before we jump into the code itself we start with a flow chart for this first program.

[mermaid,fetch-users]
....
graph LR
  A("main()") --> B[Initialize LED1]
  B --> C{Is it true?}
  C --> |yes| D[Turn on LED1]
  D --> E([Sleep 250 ms])
  E --> F[Turn off LED1]
  F --> G([Sleep 250 ms])
  G --> C
....

=== Creating a new application

=== Entering the code

Replace the contents of `main.c` (in the `src` folder) with the following code. **Always** type the code from these lab guides into the editor yourself; don't copy and paste it. You will pay more attention to the details of the code and learn it better if you type it.

[source,c]
[[program-blink-internal-LED]]
.A program to blink an internal LED.
----
/********************************
 * Heartbeat program
 * 
 * Flashes an internal LED
 *******************************/
#include <zephyr/kernel.h>        // <1>
#include <zephyr/drivers/gpio.h>

#define LED0_NODE DT_ALIAS(led0)  // <2>
static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);  // <3>

int main() {  // <4>
	gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);  // <5>
	while (true) {
		gpio_pin_set_dt(&led,1); // 1 = ACTIVE = ON
		k_msleep(250);
		gpio_pin_set_dt(&led,0); // 0 = INACTIVE = OFF
		k_msleep(250);
	}
}
----
<1> Zephyr is designed to be lightweight so only the components you need are included. These import Zephyr's Kernel and GPIO APIs.
<2> Information about the hardware is stored in something called the devicetree. This looks up the identifier for the LED associated with the alias `led0`.
<3> This creates a container called `led` that holds information about a GPIO pin.
<4> The Zephyr RTOS looks for a user-defined function called `main` to run after it completes its start-up. This is often the heart of your application.
<5> The GPIO pin linked to LED1 is configured as an output and set to be in the active (on) state.



=== Documenting the first program
Create a new file called `README.md` in the `src` folder. This is where you will put some human-friendly documentation using a simple and widely used markup language called https://guides.github.com/features/mastering-markdown/[Markdown]. We will also supplement Markdown with  https://mermaid-js.github.io/[mermaid], a diagram-drawing language that will let us include graphics like flowcharts in our documentation.

Before you start adding contents to this file, turn on VS Code's Markdown previewer by clicking on the "`Open Preview to the Side`" button (or type kbd:[Ctrl+k] and then kbd:[v]).

// [#img-vscode-markdown-preview]
// .VS Code button for Markdown preview.
// image::vscode-markdown-preview.png[Button that opens a Markdown preview in side pane, 655, 31]

Entering the following code into the `README.md` file.
[source,markdown]
[[readme-blink-internal-LED]]
.Documentation for the heart beat program.
----
# Program 1: Heartbeat                              // <1>
**Author:** John M. Larkin <jlarkin@whitworth.edu>  // <2>
**Date:** December 31, 2024

**Modified by:** 
**Date:**

**Purpose:** This program flashes an internal LED on the nRF52840 DK

## Configuration
Uses default devicetree configuration.

## Hardware                                     // <3>
### Internal
* LED1 (digital output)                         // <4>

## Flow
```mermaid                                      // <5>
graph LR                                        // <6>
  A("main()") --> B[Initialize LED1]
  B --> C{Is it true?}                          // <7>
  C --> |yes| D[Turn on LED1]                   // <8>
  D --> E([Sleep 250 ms])
  E --> F[Turn off LED1]
  F --> G([Sleep 250 ms])
  G --> C
```
----
<1> Section headings are created in Markdown by starting a line with one or more `\#` followed by a space and then the name of the section. A top-level section is one `#`, a second-level section starts with `##`, and so forth.
<2> Markdown puts text in bold if it is surrounded by `**`. It formats something as a click-able email link or URL if it is inside of `<` and `>`. Also, this line ends with two space characters. This creates a line break. Otherwise, the next line would be wrapped as a continuation of this line.
<3> Our microcontroller will nearly always be connected to additional components. Part of good documentation will be describe those in the README file.
<4> An itemized list has items that start with `\*`, then a space, and that is followed by the description of the item. The space between `*` and the description is required.
<5> The start of a mermaid code block begins with ````mermaid`.
<6> This flowchart is arranged from left to right. Another common arrangement is top to bottom (`TB`).
<7> Nodes are named (the letters) and labeled (the text inside the various delimiters). Connections between nodes are given by `-\->`. Different delimiters create different shapes of nodes. Conditional branching is traditionally inside of a diamond, created in mermaid with `{` and `}` delimiters.
<8> Text can be place along a connecting line by placing it inside of a pair of `|` after the connector code (`-\->`).

=== Modifying the first program

====
[[exercise-sweep-internal-led-flow]]
.Exercise {lab}.{counter:exercise}
Create a new application called `cycle-blinky`. In this project, create a `README.md` file. Use the README file for <<program-blink-internal-LED>> as template and modify as appropriate.

Create a flow chart for a program that would light the four integrated LEDs in the sequence LED1 -> LED2 -> LED3 -> LED4 (and then repeat forever).  Each LED should be lit for 0.25 s and it should appear that only one is on at a time (though there might actually be some very small overlap).
====

====
[[exercise-sweep-internal-led-program]]
.Exercise {lab}.{counter:exercise}
Starting with <<program-blink-internal-LED>>, change the code so that it implements the logic shown in the flow chart created for <<exercise-sweep-internal-led-flow>>.
====

IMPORTANT: Show your flow chart and working program when you are done.

== Extending the "`Hello, world`" program

The next challenge is to modify the "`Hello, world`" program to produce a more complicated LED blinking behavior.  It will flash the leftmost LED five times and then flash the rightmost LED five times, and then repeat forever.  The flow chart for this program is shown in <<img-program2-flowchart>>.

[#img-program2-flowchart]
.Flow chart for the two alternating LEDs blink program.
[mermaid,fetch-users]
....
graph TB
  B("main()") --> C[Set i to 0]
  C --> D{Do it forever?}
  D -- Yes --> E{Is i < 10?}
  E -- Yes --> F[Toggle left LED's state]
  E -- No --> I{Is i > 0?}
  F --> G([Sleep])
  G --> H(Increase i by 1)
  H --> E
  I -- Yes --> L[Toggle right LED's state]
  L --> M([Sleep])
  M --> N(Decrease i by 1)
  N --> I
  I -- No --> D
....

The code to implement this flow chart uses `while` loops that test for a condition.  While the condition is true, the content of the loop is repeated.  Create a new application (`two-hearts`) with this code and verify that it works as claimed.


[source]
[[program-blink-LED-while-loops]]
.Exploring `while` loops with blinking LEDs.
----
/********************************
 * Left-right alternating blink
 * 
 * Flashes left LED 5 times, then
 * right LED 5 times. Repeat.
 *******************************/
#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>

#define SLEEP_TIME_MS 250  // <1>

#define LED0_NI DT_ALIAS(led0)
#define LED1_NI DT_ALIAS(led1)
static const struct gpio_dt_spec leftLED = GPIO_DT_SPEC_GET(LED0_NI, gpios); // <2>
static const struct gpio_dt_spec rightLED = GPIO_DT_SPEC_GET(LED1_NI, gpios);

int main() {
	int i = 0; // <3>
	gpio_pin_configure_dt(&leftLED, GPIO_OUTPUT_INACTIVE);  // <4>
	gpio_pin_configure_dt(&rightLED, GPIO_OUTPUT_INACTIVE);
	while (true) {
		while (i<10) { // Flash the left LED five times
			gpio_pin_toggle_dt(&leftLED);  // <5>
			k_msleep(SLEEP_TIME_MS);
			i = i + 1;
		}  // <6>
		while (i>0) { // Flash the right LED five times
			gpio_pin_toggle_dt(&rightLED); // <7>
			k_msleep(SLEEP_TIME_MS);
			i = i - 1;
		}  // <8>
	}  // <9>
}
----
<1> The `#define` pre-compiler directive associates a name, `SLEEP_TIME_MS`, with a value, `250`. Before the program is compiled, the pre-compiler will replace all occurrences of `SLEEP_TIME_MS` with its value. This means that no variable memory space is associated with `SLEEP_TIME_MS`. In this program `SLEEP_TIME` is used to control the on/off time for the LEDs. If a different on/off time was desired, only this definition would need to be changed rather than hunting through the code for all occurrences of a particular number.
<2> There is usually only one connection to any particular hardware element.  Therefore, our usual design style will be to declare all objects that connect to hardware _outside_ of the `main` function.  This means that they are *global* variables accessible by any function. 
<3> The integer variable `i` is declared within the `main` function.  This means that this particular definition of `i` is *local*.  We will explore this in more detail later.
<4> The `main` function is called after the rest of the Zephyr RTOS initialization has finished. We want to wait until that is completed before we attempt to configure any hardware. Here the pins connected to the LEDs are configured as outputs and initially are turned off (inactive).
<5> The inner `while` loop for flashing the left LED begins here. This also illustrates the toggle method a digital output. Toggle changes the state from off to on or from on to off. Doing this twice is one flash of the LED. That is why the loop runs 10 times to flash the LED five times.
<6> The `while` loop for flashing the left LED ends here.  If `i` is less than 10, jump up to the top of this loop.
<7> The inner `while` loop for flashing the right LED begins here.
<8> The `while` loop for flashing the right LED ends here.  If `i` is greater than 0, jump up to the top of this loop.
<9> The never-ending outer `while` loop repeats when it reaches this point.