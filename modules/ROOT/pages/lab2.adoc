:lab: 2
:sectnums:
:imagesdir: ../images
:source-language: c
:listing-caption: Program
:example-caption: Exercise
:xrefstyle: short
:experimental:
:nrf-toolchain: v2.6.1
:nrf-sdk: 2.6.1
:Omega: &#937;
:Delta: &#916;
= Lab 2

== Internal buttons

The nRF52840 DK board has five buttons. The button set off by itself resets the board. The four buttons in a cluster are ones available for use in our code. On the board they have labels BUTTON1 through BUTTON4, but their aliases in code are `sw0` through `sw3`. If you have not encountered it before, _sw_ is a common abbreviation for _switch_ in electronics.

. Create a new application called `led-enabler`.
. Enter the following code into `main.c`.
+
[source,c]
[[program-led-enabler]]
.Use a button to turn on an LED.
----
#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>

#define SLEEP_TIME_MS   100

/* Get node identifiers for hardware */
#define LED0_NI DT_ALIAS(led0)
#define BTN0_NI DT_ALIAS(sw0) // <1>

/* Get gpio specs */
const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NI, gpios);
const struct gpio_dt_spec button = GPIO_DT_SPEC_GET(BTN0_NI, gpios); // <2>

int main(void) {
    int btn_pressed; // <3>

    if (gpio_is_ready_dt(&led)) { // <4>
        gpio_pin_configure_dt(&led, GPIO_OUTPUT_INACTIVE);
    } else { // <5>
        return -1; // <6>
    }

    if (gpio_is_ready_dt(&button)) {
        gpio_pin_configure_dt(&button, GPIO_INPUT); // <7>
    } else {
        return -1;
    }
    
    while (true) {
        btn_pressed = gpio_pin_get_dt(&button); // <8>
        gpio_pin_set_dt(&led, btn_pressed); // <9>
        k_msleep(SLEEP_TIME_MS);
    }
}
----
<1> The node identifier for BUTTON1 is obtained using its alias: `sw0`.
<2> Buttons, like LEDs, are controlled by GPIO pins. The process of getting the GPIO specifications is the same for buttons as it is for LEDs.
<3> A integer variable is declared to hold the state of the button.
<4> Although it was not done in the xref:lab1.adoc[Lab 1] examples, it is best practice to always check that peripherals are ready before attempting to use them. The function `gpio_is_ready_dt` returns `true` if the specified GPIO pin is ready. The code that follows in the curly braces will only be executed if the GPIO pin connected to the LED is ready for use.
<5> The `else` statement marks the beginning of code that will be executed if `gpio_is_ready_dt` returns `false`.
<6> The `return` command causes the `main` function to be exited, sending a value of -1 to the kernel (the code that called `main` at startup). A return value of 0 is usually used to signal success and negative values indicate various types of errors.
<7> The pin connected to BUTTON1 is configured as an input.
<8> The state of the button is read and its value (0 for released and 1 for pressed) is saved in the variable `btn_pressed`.
<9> The LED is set to have the same value as the button (on if pressed, off if released).
+
. Add the build configuration through the nRF Connect side bar and build the application.
. Connect the development board to the computer and then use the btn:[Flash] action to send the program to it.
. Verify that LED1 is only lit while BUTTON1 is held down.

== Controlling external LEDs

Light-emitting diodes (LEDs) do not have a constant resistance.  For low voltages, they have a nearly infinite resistance (allow no current to flow).  However, once the voltage exceeds a color-specific threshold, the resistance drops rapidly to nearly zero, allowing small changes in the voltage to create large changes in the current.  If too much current flows through the LED, it will overheat and die.  To prevent this, we will almost always connect a resistor in series with the LED.  A 330 {Omega} resistor keeps the current to a safe level for the LEDs we will be using and with the voltage that our microcontroller can supply.  A 330 {Omega} resistor has the color bands orange-orange-brown.  The gold band indicates that the manufacturer guarantees that the actual resistance is within 5% of the indicated value.

LEDs are also unidirectional devices.  That is, they have a preferred direction for the flow of current.  It takes a much larger voltage to cause a current to flow the "`wrong`" way (and the LED won't usually survive the experience if it does manage to happen).  To help us know which  direction they should be connected, manufacturers almost always make the legs of LEDs different lengths.  The longer leg goes on the side closer to the higher voltage and the shorter leg goes on the side closer to ground.

Construct the circuit shown in <<img-circuit1-breadboardview>> on your breadboard. The ground connection (one of the header sockets marked **GND** on the development board) should be connected to the bus strip that is marked with the blue (or black, depending on the breadboard manufacturer) line.  We will be consistent about doing this throughout the course because it will make debugging your circuits easier (and it is the convention in this field).  The apparent lengths of the LED legs in this diagram are solely due to how far they had to travel to reach their proper holes.  So, even though it appears that a longer leg is attached to the ground bus strip, that is not the case.  The *short* leg of each LED should be connected to the ground bus.

[#img-circuit1-breadboardview]
.View of the breadboard for the two LED circuit.
image::two-led-breadboard-view.png[Breadboard view of circuit 1,605,331]

Professionals would never draw a picture like <<img-circuit1-breadboardview>> to show how a circuit is connected.  Instead, a more abstract circuit diagram would be used. The diagram in <<img-circuit1-diagram>> is how they would draw this circuit.

[#img-circuit1-diagram]
.Circuit diagram for the two LED circuit.
image::two-led-circuit-diagram.png[Circuit diagram for circuit 1,282,263]

After you have assembled this circuit on the breadboard, create a new application. Then enter <<program-red-green-LEDs>>.

. Assembly this circuit on the breadboard.
. Create a new application called `external-leds`.
. Enter the following code into `main.c`.
+
[source, c]
[[program-red-green-LEDs]]
.Flash red and green LED in an alternating pattern.
----
#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>

#define SLEEP_TIME_MS   200

/* Get node identifiers for hardware */
#define RED_NI DT_ALIAS(redled)
#define GREEN_NI DT_ALIAS(greenled)

/* Get gpio specs */
const struct gpio_dt_spec redLED = GPIO_DT_SPEC_GET(RED_NI, gpios);
const struct gpio_dt_spec greenLED = GPIO_DT_SPEC_GET(GREEN_NI, gpios);

int main(void) {
    if (gpio_is_ready_dt(&redLED)) {
        gpio_pin_configure_dt(&redLED, GPIO_OUTPUT_ACTIVE);
    } else {
        return -1;
    }
    if (gpio_is_ready_dt(&greenLED)) {
        gpio_pin_configure_dt(&greenLED, GPIO_OUTPUT_INACTIVE);
    } else {
        return -1;
    }

    while (true) {
        gpio_pin_toggle_dt(&redLED);
        gpio_pin_toggle_dt(&greenLED);
        k_msleep(SLEEP_TIME_MS);
    }
}
----
. Select btn:[Add build configuration panel] through the nRF Connect side bar and select our board as the target. In a change from past procedure, uncheck the **Build after generating configuration** box. This will change the final button to btn:[Generate Configuration]. Click on this button.
+
[#img-generate-config-not-build]
.Generate the configuration but do not build the application.
image::nrf-connect-generate-configuration.png[Generate configuration,526,207]
+
. In the **Actions** section of the nRF Connect side panel, hover over the **Devicetree** entry to reveal the more options indicator (three dots) on the right. From that, select **Create overlay**.
. Select btn:[Skip] as the next step from the **Overlay file created** dialog.
. Add the following to the `nrf52840dk_nrf52840.overlay` file that was created.
+
[source, dts]
[[dtoverlay-red-green-LEDs]]
.The overlay file allows us to configure pins for use.
----
/{
  leds {
    red_led: led_4 {
      gpios = <&gpio0 29 GPIO_ACTIVE_HIGH>;
      label = "External red LED";
    };
    green_led: led_5 {
      gpios = <&gpio0 3 GPIO_ACTIVE_HIGH>;
      label = "External green LED";
    };
  };
  aliases {
    redled = &red_led;
    greenled = &green_led;
  };
};
----
+
. You now want to perform a **pristine build** (a more complete build process that is required after altering the devicetree description of the hardware). The pristine build option can be found in the **Actions** section of the nRF Connect side panel. Hovering over **Build** will reveal the pristine build icon (a circular arrow) on the right. Click on this icon.
+
[#img-pristine-build]
.The pristine build icon appears on the right hand side of the Build action upon hovering.
image::nrf-connect-pristine-build-icon.png[Pristine build icon,481,201]
+
. Use the **Flash** action to send the program to your board. If everything has been done correctly, you should see lit red and green LEDs alternating.