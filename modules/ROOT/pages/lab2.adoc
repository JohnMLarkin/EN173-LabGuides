:lab: 2
:sectnums:
:source-language: c
:listing-caption: Program
:example-caption: Exercise
:xrefstyle: short
:experimental:
:Omega: &#937;
:Delta: &#916;

= Lab 2

== Internal buttons

The nRF52840 DK board has five buttons. The button set off by itself resets the board. The four buttons in a cluster are ones available for use in our code. On the board they have labels BUTTON1 through BUTTON4, but their aliases in code are `sw0` through `sw3`. If you have not encountered it before, _sw_ is a common abbreviation for _switch_ in electronics.

. Create a new application called `led-enabler`.
. Enter the following code into `main.c`.
+
[source,c]
[[program-led-enabler]]
.Use a button to turn on an LED.
----
#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>

#define SLEEP_TIME_MS   100

/* Get node identifiers for hardware */
#define LED0_NI DT_ALIAS(led0)
#define BTN0_NI DT_ALIAS(sw0) // <1>

/* Get gpio specs */
static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NI, gpios);
static const struct gpio_dt_spec btn = GPIO_DT_SPEC_GET(BTN0_NI, gpios); // <2>

int main(void) {
    int btn_pressed; // <3>

    if (gpio_is_ready_dt(&led)) { // <4>
        gpio_pin_configure_dt(&led, GPIO_OUTPUT_INACTIVE);
    } else { // <5>
        return -1; // <6>
    }

    if (gpio_is_ready_dt(&btn)) {
        gpio_pin_configure_dt(&btn, GPIO_INPUT); // <7>
    } else {
        return -1;
    }
    
    while (true) {
        btn_pressed = gpio_pin_get_dt(&btn); // <8>
        gpio_pin_set_dt(&led, btn_pressed); // <9>
        k_msleep(SLEEP_TIME_MS);
    }
}
----
<1> The node identifier for BUTTON1 is obtained using its alias: `sw0`.
<2> Buttons, like LEDs, are controlled by GPIO pins. The process of getting the GPIO specifications is the same for buttons as it is for LEDs.
<3> A integer variable is declared to hold the state of the button, where 0 will represent released and 1 is pressed.
<4> Although it was not done in the xref:lab1.adoc[Lab 1] examples, it is best practice to always check that peripherals are ready for use before attempting to use them. The function `gpio_is_ready_dt` returns `true` if the specified GPIO pin is ready. The code that follow in the curly braces will only be executed if the GPIO pin connected to the LED is ready for use.
<5> The `else` statement marks the beginning of code that will be executed if `gpio_is_ready_dt` returns `false`.
<6> The `return` command causes the `main` function to be exited, sending a value of `-1` to the kernel (the code that called `main` at startup). A return value of 0 is usually used to signal success and negative values indicate various types of errors.
<7> The pin connected to BUTTON1 is configured as an input.
<8> The state of the button is read and its value (0 for released and 1 for pressed) is saved in the variable `btn_pressed`.
<9> The LED is set to have the same value as the button (on if pressed, off if released).
== Controlling external LEDs

Light-emitting diodes (LEDs) do not have a constant resistance.  For low voltages, they have a nearly infinite resistance (allow no current to flow).  However, once the voltage exceeds a color-specific threshold, the resistance drops rapidly to nearly zero, allowing small changes in the voltage to create large changes in the current.  If too much current flows through the LED, it will overheat and die.  To prevent this, we will almost always connect a resistor in series with the LED.  A 330 {Omega} resistor keeps the current to a safe level for the LEDs we will be using and with the voltage that our microcontroller can supply.  A 330 {Omega} resistor has the color bands orange-orange-brown.  The gold band indicates that the manufacturer guarantees that the actual resistance is within 5% of the indicated value.

LEDs are also unidirectional devices.  That is, they have a preferred direction for the flow of current.  It takes a much larger voltage to cause a current to flow the "`wrong`" way (and the LED won't usually survive the experience if it does manage to happen).  To help us know which  direction they should be connected, manufacturers almost always make the legs of LEDs different lengths.  The longer leg goes on the side closer to the higher voltage and the shorter leg goes on the side closer to ground.

Construct the circuit shown in <<img-circuit1-breadboardview>> on your breadboard. The ground connection (pin 1 of the mbed) should be connected to the bus strip that is marked with the blue (or black, depending on the breadboard manufacturer) line.  We will be consistent about doing this throughout the course because it will make debugging your circuits easier (and it is the convention in this field).  The apparent lengths of the LED legs in this diagram are solely due to how far they had to travel to reach their proper holes.  So, even though it appears that a longer leg is attached to the ground bus strip, that is not the case.  The *short* leg of each LED should be connected to the ground bus.