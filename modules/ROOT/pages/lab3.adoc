:lab: 3
:icons: font
:sectnums:
:imagesdir: ../images
:source-language: c
:listing-caption: Program
:example-caption: Exercise
:xrefstyle: short
:experimental:
:stem: latexmath
:nrf-toolchain: v2.6.1
:nrf-sdk: 2.6.1
:Omega: &#937;
:Delta: &#916;
= Lab 3: Going Deeper with Digital Input and Output

== Setting multiple pins on a GPIO port

We can think of the four internal LEDs on the nRF52840 DK as representing a 4-bit number because each LED as only two states (on and off). The value represented by a particular LED when it is turned on is given in <<table-leds-as-bits>>. The advantage of this representation is that it becomes possible to set the state of all four LEDs with a single command rather than four commands that individually set each LED. All possible on-off combinations of the LEDs can be represented by an integer between 0 and 15.

[[table-leds-as-bits]]
.A series of LEDs can be represented as bits.
[cols="1,1,1"]
|===
|LED |Value as Power of 2|Value

|`led0`
|stem:[2^0]
|1

|`led1`
|stem:[2^1]
|2

|`led2`
|stem:[2^2]
|4

|`led3`
|stem:[2^3]
|8
|===

This approach only works when the pins we wish to group are all connected to the same GPIO controller. There are two GPIO controller peripherals on the nRF52840 DK, labeled port 0 and port 1. This approach is also easier when the pins we wish to control have consecutive pin numbers. The four internal LEDs are connected to pins 13, 14, 15, and 16 of port 0 so we can use this method.

We only want to impact those particular pins and not others so a _mask_ is used to specify that. There are 32 pins #NOT DONE#

[source, c]
[[program-leds-via-port]]
.Set state of multiple LEDs with single command.
----
#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/device.h>
#include <zephyr/devicetree.h>

#define SLEEP_TIME_MS   500

/* Get node identifiers */
#define PORT0_NI DT_NODELABEL(gpio0)

/* Get device */
const struct device *port = DEVICE_DT_GET(PORT0_NI);

int main(void) {
    int led_states;
    int led_mask = BIT(13) | BIT(14) | BIT(15) | BIT(16);

    if (device_is_ready(port)) {
        for (int pin = 13; pin <= 16; pin++) {
            gpio_pin_configure(port, pin, GPIO_OUTPUT_ACTIVE | GPIO_ACTIVE_LOW);
        }
    } else return -1;

    while (true) {
        led_states = 1;
        while (led_states < 16) {
            gpio_port_set_masked(port, led_mask, led_states << 13);
            k_msleep(SLEEP_TIME_MS);
            led_states = 2*led_states;
        }
    }
}
----

#NOT DONE#

== Physical switches and buttons

=== Selecting external LEDs with a slide switch

In this example a slide switch (single pole, double throw) is used to create either a high voltage or low voltage on a digital input.  If the input is high, a red LED will flash.  If the input is low, a green LED will flash.

Construct the circuit shown in <<img-circuit2-breadboardview>> (breadboard view) and <<img-circuit2-diagram>> (circuit diagram) on your breadboard. The apparent lengths of the LED legs in this diagram are solely due to how far they had to travel to reach their proper holes. The *long* leg of each LED should be connected to the microcontroller pins.

[#img-circuit2-breadboardview]
.View of the breadboard for the two LED circuit with switch selection.
image::external-leds-switch-breadboard.png[Breadboard view of circuit 1,379]

[#img-circuit2-diagram]
.Circuit diagram for the two LED circuit with switch selection.
image::external-leds-switch-diagram.png[Diagram of circuit 1,450]

. Create a new application and enter the code shown in <<program-led-selector>> into `main.c`.
+
[source, c]
[[program-led-selector]]
.Flash red or green LED depending on switch position.
----
#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/device.h>

#define SLEEP_TIME 200

/* Get node identifiers using label */ // <1>
#define RED_NI DT_NODELABEL(red_led)
#define GREEN_NI DT_NODELABEL(green_led)
#define SWITCH_NI DT_NODELABEL(slider)

/* Get gpio specs */
const struct gpio_dt_spec redLED = GPIO_DT_SPEC_GET(RED_NI, gpios);
const struct gpio_dt_spec greenLED = GPIO_DT_SPEC_GET(GREEN_NI, gpios);
const struct gpio_dt_spec slideSwitch = GPIO_DT_SPEC_GET(SWITCH_NI, gpios);

int main() {
    if (device_is_ready(redLED.port)) { // <2>
        gpio_pin_configure_dt(&redLED, GPIO_OUTPUT_ACTIVE);
        gpio_pin_configure_dt(&greenLED, GPIO_OUTPUT_ACTIVE);
        gpio_pin_configure_dt(&slideSwitch, GPIO_INPUT);
    } else return -1;

    while (true) {
        if (gpio_pin_get_dt(&slideSwitch)) {  // <3>
            gpio_pin_toggle_dt(&redLED);
            k_msleep(SLEEP_TIME);
        } else { 
            gpio_pin_toggle_dt(&greenLED);
            k_msleep(SLEEP_TIME);
        }
    }
}
----
<1> #NOT DONE# A `DigitalIn` has a value of either 1 (if the voltage is above the 2.3 V) or 0 (if the voltage is below 1.0 V).  Recall that 1 means true and 0 means false, so no additional logic testing is necessary.
<2> A more compact way to create blinking uses the logical NOT operator `!`. The NOT operator changes true values (or a 1) to false (or a 0) and a false value (or a 0) to true (or a 1). With this approach you can cut the code in half because you don't need separate off and on sections.
+
. Select btn:[Add build configuration panel] through the nRF Connect side bar and select our board as the target. Uncheck the **Build after generating configuration** box so the final button becomes btn:[Generate Configuration]. Click on this button.
. In the **Actions** section of the nRF Connect side panel, hover over the **Devicetree** entry to reveal the more options indicator (three dots) on the right. From that, select **Create overlay**.
. Select btn:[Skip] as the next step from the **Overlay file created** dialog.
. Add the following to the `nrf52840dk_nrf52840.overlay` file that was created.
+
[source, dts]
[[dtoverlay-led-selector]]
.The overlay file allows us to configure both input and output pins.
----
/{
  leds {
    red_led: led_4 { // <1>
      gpios = <&gpio0 28 GPIO_ACTIVE_HIGH>;
      label = "External red LED";
    };
    green_led: led_5 {
      gpios = <&gpio0 29 GPIO_ACTIVE_HIGH>;
      label = "External green LED";
    };
  };
  buttons { // <2>
    slider: button_4 { // <3>
      gpios = <&gpio0 3 GPIO_ACTIVE_HIGH>; // <4>
      label = "External SPDT slide switch";
    }
  }
};
----
<1> Our first new node in the devicetree has a node identifier of `led_4` and a label of `red_led`. We are using the label rather than an alias to access this node in `main.c`.
<2> A `button` section exists in the devicetree for GPIO inputs. We are adding an entry to this section.
<3> Our external slide switch is given the label `slider` and has the node identifier `button_4` (`button_0` through `button_3` are the buttons on the development board).
<4> This switch is connected to P0.03 and will have a `true` value when the voltage is high.
+
. You now want to perform a **pristine build** because the devicetree has been altered. The pristine build option can be found in the **Actions** section of the nRF Connect side panel. Hovering over **Build** will reveal the pristine build icon. Click on it.
. Use the **Flash** action to send the program to your board. If everything has been done correctly, in one position of the switch the red LED will flash and if it is slid into the other position the green LED will flash.

IMPORTANT: Demonstrate that you have successfully assembled this circuit and downloaded this program.

NOTE: Leave the switch in place when you are done but remove the LEDs and resistors.

=== Heart rate selector

Our goal in this section is to create a program that uses the switch to select the rate that an LED flashes. When the switch is in the OFF position it will flash at a fast rate (five times per second) and when it is in the ON position it will flash at a slower rate (one time per second). This means we need to switch between the two possible sleep times. As an additional goal we want to make it easy to find and change the two heart rate settings. We will need some new programming tools to pull this off.

==== Preprocessor definitions make code easier to read

Rather than putting specific numbers into your code where they are actually used, a good design approach is to instead associate those numbers with symbolic names. Those symbolic definitions should be put in one place so they are easy to find. This may not seem that important with small programs, but as your programs grow in complexity it will be a helpful habit.

We can use a preprocessor directive to do this. As you may recall, the first step of the build process is to have the preprocessor manipulate your source code file before it is passed to the compiler. The `#define` directive is the particular method we will use for this task. It allows us to create find-and-replace rules. In the heart rate selector program we will have the following find-and-replace rules:
----
  #define FAST_HEART_RATE 5
  #define SLOW_HEART_RATE 1
  #define ONE_SECOND 1000ms
----
After the `#define` directive we give a symbolic name (our convention will be to write this in all upper case with underscores between words, a formatting called *upper snake case*). This is followed by a space and then the text we want to have replace that symbolic name. Here I have defined the two rates as well as the chrono duration literal corresponding to 1 second (but expressed in milliseconds).

Later in the code the `sleep_for` command for fast flashing is written using the symbolic names:
----
  ThisThread::sleep_for(ONE_SECOND / FAST_HEART_RATE / 2);
----
but this is not what the compiler will see. Instead the preprocessor will replace each symbolic name with its value so the compiler gets:
----
  ThisThread::sleep_for(1000ms / 5 / 2);
----
The `ONE_SECOND / FAST_HEART_RATE` calculates the total on-and-off time for one blink. Half of this should be for on and other half for off so that is why there is the additional `/ 2`.

==== The heart rate selector code

Create a new program with the contents of <<program-blinkselector>> and then upload to the microcontroller. Verify that the flashing LED has two different rates: a faster one when the button is not pressed and a slower one when it is held down.

[source]
[[program-blinkselector]]
.Program to select the LED flashing rate using a switch
----
#include "mbed.h"

// Flashing rates in blinks per second
#define FAST_HEART_RATE 5
#define SLOW_HEART_RATE 1
#define ONE_SECOND 1000ms

DigitalOut switchIndicator(LED1);
DigitalOut heart(LED4);
DigitalIn switchInput(p7);

int main() {
  while (true) {
    heart = !heart;
    switchIndicator = switchInput;
    if (switchInput) {
      ThisThread::sleep_for(ONE_SECOND / FAST_HEART_RATE / 2);
    } else {
      ThisThread::sleep_for(ONE_SECOND / SLOW_HEART_RATE / 2);
    }
  }
}
----

== Your Turn

The remaining activities today will be done as pair programming assignments (that is, with a partner). Go to our Blackboard page and look up your partner assignment for today.

====
[[assignment-momentary-button-selector]]
.Assignment {lab}.{counter:assignment}
Repeat <<program-led-selector>> (with the red and green LEDs) but replace the slide switch with a momentary push button.  This is a SPST (single pole, single throw) button despite having four terminals.  However, pairs of terminals are connected so there are really only two independent terminals.  When the button is pushed down, the terminals on opposite sides are connected.  Remember, the default configuration of a digital input is to use an internal pull-down resistor.

IMPORTANT: Remember to document your hardware connections in `README.md`.
====

====
[[assignment-rate-toggler]]
.Assignment {lab}.{counter:assignment}
We can also make the action of a complete button press (depressed followed by a release) toggle between two different blinking rates. This means that we need to keep track of additional information that reflects its history, not just the current status of the button. This information is called the *state* of the system. In this example there are two important state variables to store:

* item the current flash rate (which has two options, slow and fast)
* item the previous status of the button

as well as the current status of the button. The flow diagram in <<img-blinkratetogglerflow>> gives an overview of the logic required to implement blink rate toggling with this state information.

[#img-blinkratetogglerflow]
.Diagram of the logic for the blink rate toggle program. This requires two stored state variables: one for the blink rate and one for the previous button status.
image::heart_rate_toggler.png[Breadboard view of circuit 1,324]

Because `DigitalIn` reports its status using an integer, it makes sense to store that status in an integer. The other state variable holds information about the flash rate mode. In the current program we only have two possible options for that, but we could easily imagine that in the future we might want to add a third or even a fourth option. Because it is countable an obvious choice is once again an integer variable. We could use the standard `int`` for this, but to make the code easier for humans to understand we will instead use a special integer version: `enum`.

The name `enum` is short for enumerated. This is a word that means something is associated with a number. In this case we are going to write our program using human-friendly names to refer to the different flashing rate modes, but behind the scenes these will be stored as integers. The first thing we do is to define that enumeration:
----
  enum rateState_t {FastMode, SlowMode};
----
Our custom variable type is given the name `rateState_t`. It has only two possible values: `FastMode` and `SlowMode`. The computer treats these as if they were the numbers 0 (for `FastMode`) and 1 (for `SlowMode`).

NOTE: The Mbed OS convention is to end custom variable type names with `_t` and to write the possible value names of an `enum` in upper camel case. 

Inside of the `main` function we will then declare a variable `rateMode` that is of this type and is initially set to the fast mode.
----
  rateState_t rateMode = FastMode;
----
The meaning of this is less ambiguous to a human reader of the code than the alternative version using the standard `int`:
----
  int rateMode = 0;
----

We have previously toggled an integer using the NOT operator `!` so you might think we could write
----
  rateMode = !rateMode;
----
to switch from one rate mode to the other. However, there is a problem which is best illustrated with an example scenario. Suppose we start with `rateMode` equal to `FastMode`. We know that `FastMode` is represented by 0 and `!0` is 1. We might think that this would be no problem because `SlowMode` corresponds to 1. However, there is directionality to that correspondence. Names are automatically converted to their corresponding integers but integers are not automatically converted to the names. This results in an error because an `enum` variable wants only the defined names to be assigned to it and 1 is not one of those names. To get around this, we need to explicitly tell the compiler to convert integers to names. We do this by telling it the mapping to use in parentheses to the left of the operation that produces the integer. This means that correct way to produce toggling behavior is
----
  rateMode = (rateState_t)!rateMode;
----
This conversion from one variable type (`int`) to another (`rateState_t`) is called *type casting*.

The previous program had an `if...else` statement with a simple condition. The state of the button was either 0 or 1. This time we will need to write more complicated conditions. We will consider the easier of those first: selecting the appropriate sleep time based on `rateMode`. In this case all we need to do is to check whether `rateMode` is equal to `FastMode`.

As we have seen earlier, the `=` operator doesn't mean "`Is the thing on the left equal to the thing on the right?`" Instead, it means "`Assign the value of the thing on the right to the thing on the left.`'' In other words, it is a command, not a question. So how do we ask whether `rateMode` is equal to `FastMode`? The answer in C++ is the logical equal operator `==` (two consecutive equal sign characters). This means that we will write
----
  if (rateMode == FastMode) {
----
to begin the `if...else` statement.

Next we have the compound condition "`Is the current button state different than the previous button state AND is the button currently released?`" We can break this into three questions:

* Is the button currently released?
* Is the current button state not equal to the previous button state?
* Are the answers to questions 1 and 2 both yes?

We will now look at each these in turn, assuming the current state of the button is saved to `currBtn` and the previous state of the button to `prevBtn`.
[horizontal,labelwidth=20]
Question 1:: Remembering that the button reads high when it is released, the condition corresponding to the question "`Is the button currently released?`" is simply `currBtn`.
Question 2:: The NOT EQUAL logic operator in C++ is `!=`. This means the condition "`Is the current button state NOT EQUAL to the previous button state?`" is `currBtn != prevBtn`.
Question 3:: The question "`Are the answers to questions 1 and 2 both yes`" requires the AND logic operator. In C++ AND is written as `&&`. We need to enclose each of the condition statements inside of parentheses so the opening of this `if...else` structure is finally given as:
----
if ((currBtn != prevBtn) && (currBtn)) {
----

Create a new program with the contents of <<program-blinktoggler>> and then upload to the microcontroller. Verify that the rate of the flashing LED toggles between its two rates when you press-and-release the button. You should observe that sometimes the rate doesn't toggle correctly if the press-and-release happens too quickly. We will learn techniques later that avoid this problem.

[source]
[[program-blinktoggler]]
.Program to toggle the LED flashing rate using a button.
----
#include "mbed.h"

DigitalOut btnIndicator(LED1);
DigitalOut heart(LED4);
DigitalIn pb(p7);

// Flashing rates in blinks per second
#define FAST_HEART_RATE 5
#define SLOW_HEART_RATE 1
#define ONE_SECOND 1000ms

enum rateState_t {FastMode, SlowMode};

int main() {
  rateState_t rateMode = FastMode;
  int prevBtn = pb.read();
  int currBtn;
  
  while (true) {
    heart = !heart;
    currBtn = pb.read(); // Read button once per loop
    btnIndicator = currBtn;
    if ((currBtn != prevBtn) && (currBtn)) {
        rateMode = (rateState_t)!rateMode;
    }
    prevBtn = currBtn;
    if (rateMode == FastMode) {
      ThisThread::sleep_for(ONE_SECOND / FAST_HEART_RATE / 2);
    } else {
      ThisThread::sleep_for(ONE_SECOND / SLOW_HEART_RATE / 2);
    }
  }
}
----

Your first task in this assignment is to explain *why* the rate will sometimes fail to toggle if the press-and-release of the button happens too quickly. Does _too quickly_ always have the same meaning or does it depend on the current flashing rate?

Your second task is to intentionally make an error, changing the condition of the `if` to `rateMode = FastMode` (where the assignment operator is used instead of the logical equality operator). Build the project. Does the compiler give you any indication that something might be wrong?
Next, upload the modified program to the microcontroller. Observe the new behavior and explain *why* it does what it does.
====