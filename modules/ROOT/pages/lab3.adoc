:lab: 3
:icons: font
:sectnums:
:imagesdir: ../images
:source-language: c
:listing-caption: Program
:example-caption: Exercise
:xrefstyle: short
:experimental:
:stem: latexmath
:nrf-toolchain: v2.6.1
:nrf-sdk: 2.6.1
:Omega: &#937;
:Delta: &#916;
= Lab 3: Going Deeper with Digital Input and Output

== Setting multiple pins on a GPIO port

We can think of the four internal LEDs on the nRF52840 DK as representing a 4-bit number because each LED as only two states (on and off). The value represented by a particular LED when it is turned on is given in <<table-leds-as-bits>>. The advantage of this representation is that it becomes possible to set the state of all four LEDs with a single command rather than four commands that individually set each LED. All possible on-off combinations of the LEDs can be represented by an integer between 0 and 15.

[[table-leds-as-bits]]
.A series of LEDs can be represented as bits.
[cols="1,1,1"]
|===
|LED |Value as Power of 2|Value

|`led0`
|stem:[2^0]
|1

|`led1`
|stem:[2^1]
|2

|`led2`
|stem:[2^2]
|4

|`led3`
|stem:[2^3]
|8
|===

This approach only works when the pins we wish to group are all connected to the same GPIO controller. There are two GPIO controller peripherals on the nRF52840 DK, labeled port 0 and port 1. This approach is also easier when the pins we wish to control have consecutive pin numbers. The four internal LEDs are connected to pins 13, 14, 15, and 16 of port 0 so we can use this method.

We only want to impact those particular pins and not others so a _mask_ is used to specify that. There are 32 pins #NOT DONE#

[source, c]
[[program-leds-via-port]]
.Set state of multiple LEDs with single command.
----
#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/device.h>
#include <zephyr/devicetree.h>

#define SLEEP_TIME_MS   500

/* Get node identifiers */
#define PORT0_NI DT_NODELABEL(gpio0)

/* Get device */
const struct device *port = DEVICE_DT_GET(PORT0_NI);

int main(void) {
    int led_states;
    int led_mask = BIT(13) | BIT(14) | BIT(15) | BIT(16);

    if (device_is_ready(port)) {
        for (int pin = 13; pin <= 16; pin++) {
            gpio_pin_configure(port, pin, GPIO_OUTPUT_ACTIVE | GPIO_ACTIVE_LOW);
        }
    } else return -1;

    while (true) {
        led_states = 1;
        while (led_states < 16) {
            gpio_port_set_masked(port, led_mask, led_states << 13);
            k_msleep(SLEEP_TIME_MS);
            led_states = 2*led_states;
        }
    }
}
----

#NOT DONE#

== Physical switches and buttons

=== Selecting external LEDs with a slide switch

In this example a slide switch (single pole, double throw) is used to create either a high voltage or low voltage on a digital input.  If the input is high, a red LED will flash.  If the input is low, a green LED will flash.

Construct the circuit shown in <<img-circuit2-breadboardview>> (breadboard view) and <<img-circuit2-diagram>> (circuit diagram) on your breadboard. The apparent lengths of the LED legs in this diagram are solely due to how far they had to travel to reach their proper holes. The *long* leg of each LED should be connected to the microcontroller pins.

[#img-circuit2-breadboardview]
.View of the breadboard for the two LED circuit with switch selection.
image::lab3/external-leds-switch-breadboard.png[Breadboard view of circuit 1,379]

[#img-circuit2-diagram]
.Circuit diagram for the two LED circuit with switch selection.
image::lab3/external-leds-switch-diagram.png[Diagram of circuit 1,450]

. Create a new application and enter the code shown in <<program-led-selector>> into `main.c`.
+
[source, c]
[[program-led-selector]]
.Flash red or green LED depending on switch position.
----
#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/device.h>

#define SLEEP_TIME 200

/* Get node identifiers using label */ // <1>
#define RED_NI DT_NODELABEL(red_led)
#define GREEN_NI DT_NODELABEL(green_led)
#define SWITCH_NI DT_NODELABEL(slider)

/* Get gpio specs */
const struct gpio_dt_spec redLED = GPIO_DT_SPEC_GET(RED_NI, gpios);
const struct gpio_dt_spec greenLED = GPIO_DT_SPEC_GET(GREEN_NI, gpios);
const struct gpio_dt_spec slideSwitch = GPIO_DT_SPEC_GET(SWITCH_NI, gpios);

int main() {
    if (device_is_ready(redLED.port)) { // <2>
        gpio_pin_configure_dt(&redLED, GPIO_OUTPUT_ACTIVE);
        gpio_pin_configure_dt(&greenLED, GPIO_OUTPUT_ACTIVE);
        gpio_pin_configure_dt(&slideSwitch, GPIO_INPUT);
    } else return -1;

    while (true) {
        if (gpio_pin_get_dt(&slideSwitch)) {  // <3>
            gpio_pin_toggle_dt(&redLED);
            k_msleep(SLEEP_TIME);
        } else { 
            gpio_pin_toggle_dt(&greenLED);
            k_msleep(SLEEP_TIME);
        }
    }
}
----
// Verified with SDK 2.6.1 and nRF52840 DK on 10/2/2024
<1> It is possible to get node identifiers using node labels rather than using an alias. The alias approach is best when a program is meant to run on many different boards, each of which may have reasons for choosing other node labels for various components. However, if you are just developing for a single board then the node label approach avoids extra code in the overlay file.
<2> All of the pins that were selected are on the same port. If the port controller is ready, it is ready for all of them. The `device_is_ready` method is a more general test of readiness that works with both GPIO controllers and much more.
<3> Get the state of slide switch. A value of `true` (equivalent to 1) means the middle pin of the slide switch is connected to the high voltage. If that is the case, flash the red LED. Otherwise, flash the green LED.
+
. Select btn:[Add build configuration panel] through the nRF Connect side bar and select our board as the target. Uncheck the **Build after generating configuration** box so the final button becomes btn:[Generate Configuration]. Click on this button.
. In the **Actions** section of the nRF Connect side panel, hover over the **Devicetree** entry to reveal the more options indicator (three dots) on the right. From that, select **Create overlay**.
. Select btn:[Skip] as the next step from the **Overlay file created** dialog.
. Add the following to the `nrf52840dk_nrf52840.overlay` file that was created.
+
[source, dts]
[[dtoverlay-led-selector]]
.The overlay file allows us to configure both input and output pins.
----
/{
  leds {
    red_led: led_4 { // <1>
      gpios = <&gpio0 28 GPIO_ACTIVE_HIGH>;
      label = "External red LED";
    };
    green_led: led_5 {
      gpios = <&gpio0 29 GPIO_ACTIVE_HIGH>;
      label = "External green LED";
    };
  };
  buttons { // <2>
    slider: button_4 { // <3>
      gpios = <&gpio0 3 GPIO_ACTIVE_HIGH>; // <4>
      label = "External SPDT slide switch";
    };
  };
};
----
<1> Our first new node in the devicetree has a node identifier of `led_4` and a label of `red_led`. We are using the label rather than an alias to access this node in `main.c`.
<2> A `button` section exists in the devicetree for GPIO inputs. We are adding an entry to this section.
<3> Our external slide switch is given the label `slider` and has the node identifier `button_4` (`button_0` through `button_3` are the buttons on the development board).
<4> This switch is connected to P0.03 and will have a `true` value when the voltage is high.
+
. You now want to perform a **pristine build** because the devicetree has been altered. The pristine build option can be found in the **Actions** section of the nRF Connect side panel. Hovering over **Build** will reveal the pristine build icon. Click on it.
. Use the **Flash** action to send the program to your board. If everything has been done correctly, in one position of the switch the red LED will flash and if it is slid into the other position the green LED will flash.

IMPORTANT: Demonstrate that you have successfully assembled this circuit and downloaded this program.

NOTE: Leave the switch, the red LED, and the resistor connected to the red LED in place when you are done. You may remove the green LED and its resistor.

=== Heart rate selector

Our goal in this section is to create a program that uses the switch to select the rate that an LED flashes. When the switch is in the OFF position it will flash at a fast rate (five times per second) and when it is in the ON position it will flash at a slower rate (one time per second). This means we need to switch between the two possible sleep times. As an additional goal we want to make it easy to find and change the two heart rate settings. We will need some new programming tools to pull this off.

==== Preprocessor definitions make code easier to read

Rather than putting specific numbers into your code where they are actually used, a good design approach is to instead associate those numbers with symbolic names. Those symbolic definitions should be put in one place so they are easy to find. This may not seem that important with small programs, but as your programs grow in complexity it will be a helpful habit.

We can use a preprocessor directive to do this. As you may recall, the first step of the build process is to have the preprocessor manipulate your source code file before it is passed to the compiler. The `#define` directive is the particular method we will use for this task. It allows us to create find-and-replace rules. In the heart rate selector program we will have the following find-and-replace rules:
----
  #define FAST_HEART_SLEEP  100
  #define SLOW_HEART_SLEEP  500
----
After the `#define` directive we give a symbolic name (our convention will be to write this in all upper case with underscores between words, a formatting called *upper snake case*). This is followed by a space and then the text we want to have replace that symbolic name. Here I have defined the two sleep times.

Later in the code the `k_msleep` command for fast flashing is written using the symbolic names:
----
  k_msleep(FAST_HEART_SLEEP);
----
but this is not what the compiler will see. Instead the preprocessor will replace the symbolic name with its value so the compiler gets:
----
  k_msleep(100);
----

==== The heart rate selector code

Create a new program with the contents of <<program-blinkselector>>, create an appropriate devicetree overlay (for the red LED and the slide switch), build the code, and then flash it to the microcontroller. Verify that the flashing LED has two different rates: a faster one when the button is not pressed and a slower one when it is held down.

[source,c]
[[program-blinkselector]]
.Program to select the LED flashing rate using a switch
----
#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/device.h>

#define FAST_HEART_SLEEP  100
#define SLOW_HEART_SLEEP  500

/* Get node identifiers using label */
#define RED_NI DT_NODELABEL(red_led)
#define SWITCH_NI DT_NODELABEL(slider)

/* Get gpio specs */
const struct gpio_dt_spec redLED = GPIO_DT_SPEC_GET(RED_NI, gpios);
const struct gpio_dt_spec slideSwitch = GPIO_DT_SPEC_GET(SWITCH_NI, gpios);

int main() {
    if (device_is_ready(redLED.port)) { // <2>
        gpio_pin_configure_dt(&redLED, GPIO_OUTPUT_ACTIVE);
        gpio_pin_configure_dt(&slideSwitch, GPIO_INPUT);
    } else return -1;

    while (true) {
        gpio_pin_toggle_dt(&redLED);
        if (gpio_pin_get_dt(&slideSwitch)) {
            k_msleep(FAST_HEART_SLEEP);
        } else {
            k_msleep(SLOW_HEART_SLEEP);
        }
    }
}
----

== Your Turn

The remaining activities today will be done as pair programming assignments (that is, with a partner). Go to our Blackboard page and look up your partner assignment for today.

====
[[assignment-momentary-button-selector]]
.Assignment {lab}.{counter:assignment}
#Repeat <<program-led-selector>> (with the red and green LEDs) but replace the slide switch with a momentary push button.  This is a SPST (single pole, single throw) button despite having four terminals.  However, pairs of terminals are connected so there are really only two independent terminals.  When the button is pushed down, the terminals on opposite sides are connected.  Remember, the default configuration of a digital input is to use an internal pull-down resistor.#

IMPORTANT: Remember to document your hardware connections in `README.md`.
====

The next activity will only use an internal LED and an internal button. You can disconnect the components from your development board and remove them from the breadboard.

====
[[assignment-rate-toggler]]
.Assignment {lab}.{counter:assignment}
We can also make the action of a complete button press (depressed followed by a release) rotate through three different blinking rates. This means that we need to keep track of additional information that reflects its history, not just the current status of the button. This information is called the *state* of the system. In this example there are two important state variables to store:

* the current flash rate (which has three options: slow, medium, and fast)
* the previous status of the button

as well as the current status of the button. The flow diagram in <<img-blinkratetogglerflow>> gives an overview of the logic required to implement blink rate toggling with this state information.

[#img-blinkratetogglerflow]
.Diagram of the logic for the blink rate toggle program. This requires two stored state variables: one for the blink rate and one for the previous button status.
image::lab3/heart_rate_toggler.png[Breadboard view of circuit 1,324]

Because a GPIO input reports its status using an integer, it makes sense to store that status in an integer. The other state variable holds information about the flash rate mode. In the current program we have three possible options for that, but we could easily imagine that in the future we might want to add a fourth option. Because it is countable an obvious choice is once again an integer variable. We could use the standard `int` for this, but to make the code easier for humans to understand we will instead use a special integer version: `enum`.

The name `enum` is short for enumerated. This is a word that means something is associated with a number. In this case we are going to write our program using human-friendly names to refer to the different flashing rate modes, but behind the scenes these will be stored as integers. The first thing we do is to define that enumeration:
----
  enum rateState_t {FastMode, MediumMode, SlowMode};
----
Our custom variable type is given the name `rateState_t`. It has only three possible values: `FastMode`, `MediumMode` and `SlowMode`. The computer treats these as if they were the numbers 0 (for `FastMode`), 1 (for `MediumMode`), and 2 (for `SlowMode`).

NOTE: A C convention is to end custom variable type names with `_t` and to write the possible value names of an `enum` in upper camel case. 

Inside of the `main` function we will then declare a variable `rateMode` that is of this type and is initially set to the fast mode.
----
  enum rateState_t rateMode = FastMode;
----
The meaning of this is less ambiguous to a human reader of the code than the alternative version using the standard `int`:
----
  int rateMode = 0;
----

The previous program had an `if...else` statement with a simple condition. The state of the button was either 0 or 1. This time we will need to select among three (or possibly more) options based on the value of `rateMode`. We could use a series of `if` statements to direct the code, but a better solution in C is the `switch` structure.

A `switch` structure begins by specifying the variable that we will be testing. We then specify the possible options using the `case` keyword. The code to be run if that option is selected follows and `break;` indicates where it ends. In our case this becomes
[source,c]
----
switch (rateMode) {
    case FastMode:
        k_msleep(FAST_SLEEP_TIME);
        break;
    case MediumMode:
        k_msleep(MEDIUM_SLEEP_TIME);
        break;
    case SlowMode:
        k_msleep(SLOW_SLEEP_TIME);
        break;
}
----

Next we have the compound condition "`Is the current button state different than the previous button state AND is the button currently released?`" We can break this into three questions:

* Is the button currently released?
* Is the current button state not equal to the previous button state?
* Are the answers to questions 1 and 2 both yes?

We will now look at each these in turn, assuming the current state of the button is saved to `currBtn` and the previous state of the button to `prevBtn`.
[horizontal,labelwidth=20]
Question 1:: Remembering that the button reads high when it is released, the condition corresponding to the question "`Is the button currently released?`" is simply `currBtn`.
Question 2:: The NOT EQUAL logic operator in C is `!=`. This means the condition "`Is the current button state NOT EQUAL to the previous button state?`" is `currBtn != prevBtn`.
Question 3:: The question "`Are the answers to questions 1 and 2 both yes`" requires the AND logic operator. In C AND is written as `&&`. We need to enclose each of the condition statements inside of parentheses so the opening of this `if...else` structure is finally given as:
----
if ((currBtn != prevBtn) && (currBtn)) {
----

Create a new program with the contents of <<program-blinktoggler>> and then upload to the microcontroller. Verify that the rate of the flashing LED rotates through its three rates when you press-and-release the button.

[source,c]
[[program-blinktoggler]]
.Program to toggle the LED flashing rate using a button.
----
#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>

#define FAST_SLEEP_TIME   100
#define MEDIUM_SLEEP_TIME 200
#define SLOW_SLEEP_TIME   500

/* Get node identifiers */
#define LED0_NI DT_ALIAS(led0)
#define BTN0_NI DT_ALIAS(sw0)

/* Get gpio specs */
const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NI, gpios);
const struct gpio_dt_spec button = GPIO_DT_SPEC_GET(BTN0_NI, gpios);

enum rateState_t {FastMode, MediumMode, SlowMode};

int main() {
    enum rateState_t rateMode = FastMode;
    int prevBtn, currBtn;

    if (gpio_is_ready_dt(&led) && gpio_is_ready_dt(&button)) {
        gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);
        gpio_pin_configure_dt(&button, GPIO_INPUT);
    } else return -1;

    prevBtn = gpio_pin_get_dt(&button);
    while (true) {
        gpio_pin_toggle_dt(&led);
        currBtn = gpio_pin_get_dt(&button);
        if ((currBtn != prevBtn) && (currBtn)) {
            switch (rateMode) {
              case FastMode: rateMode = MediumMode; break;
              case MediumMode: rateMode = SlowMode; break;
              case SlowMode: rateMode = FastMode; break;
            }
        }
        prevBtn = currBtn;
        switch (rateMode) {
            case FastMode: k_msleep(FAST_SLEEP_TIME); break;
            case MediumMode: k_msleep(MEDIUM_SLEEP_TIME); break;
            case SlowMode: k_msleep(SLOW_SLEEP_TIME); break;
        }
    }
}
----

Your task in this assignment is to explain *why* the rate will sometimes fail to toggle if the press-and-release of the button happens too quickly. Does _too quickly_ always have the same meaning or does it depend on the current flashing rate?
====